<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>End-to-End ML Project: California Housing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .nav-menu {
            background: #34495e;
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav-menu ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }

        .nav-menu a {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: background 0.3s;
            font-size: 0.9rem;
        }

        .nav-menu a:hover {
            background: #3498db;
        }

        .step {
            margin: 2rem;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            background: white;
            border-left: 5px solid #3498db;
        }

        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .step-number {
            background: #3498db;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 1rem;
        }

        .step-title {
            font-size: 1.8rem;
            color: #2c3e50;
        }

        .concept-box {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid #4caf50;
        }

        .concept-box.problem {
            background: #fff3e0;
            border-color: #ff9800;
            border-left-color: #ff9800;
        }

        .concept-box.solution {
            background: #e3f2fd;
            border-color: #2196f3;
            border-left-color: #2196f3;
        }

        .concept-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }

        .collapsible {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            margin: 1rem 0;
        }

        .collapsible-header {
            background: #e9ecef;
            padding: 1rem;
            cursor: pointer;
            font-weight: bold;
            user-select: none;
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .collapsible-header:hover {
            background: #dee2e6;
        }

        .collapsible-content {
            padding: 1rem;
            display: none;
        }

        .collapsible-content.active {
            display: block;
        }

        .toggle-icon {
            margin-left: auto;
            transition: transform 0.3s;
        }

        .toggle-icon.active {
            transform: rotate(180deg);
        }

        .pipeline-viz {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin: 2rem 0;
            gap: 1rem;
        }

        .pipeline-step {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            min-width: 150px;
            position: relative;
        }

        .pipeline-step:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .pipeline-step.active {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .arrow {
            font-size: 1.5rem;
            color: #3498db;
            margin: 0 0.5rem;
        }

        .plot-container {
            margin: 1.5rem 0;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }

        .metric-card {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
            border-top: 4px solid #3498db;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .metric-label {
            color: #7f8c8d;
            font-size: 1rem;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            color: #3498db;
            font-weight: bold;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #2c3e50;
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .interactive-demo {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .slider-container {
            margin: 1rem 0;
        }

        .slider {
            width: 100%;
            margin: 0.5rem 0;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        @media (max-width: 768px) {
            .nav-menu ul {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .pipeline-viz {
                flex-direction: column;
                align-items: center;
            }
            
            .arrow {
                transform: rotate(90deg);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè† End-to-End ML Project</h1>
            <p>California Housing Price Prediction - Interactive Guide</p>
        </div>

        <nav class="nav-menu">
            <ul>
                <li><a href="#step1">Frame Problem</a></li>
                <li><a href="#step2">Get Data</a></li>
                <li><a href="#step3">Explore Data</a></li>
                <li><a href="#step4">Prepare Data</a></li>
                <li><a href="#step5">Train Model</a></li>
                <li><a href="#step6">Fine-tune</a></li>
                <li><a href="#step7">Evaluate</a></li>
            </ul>
        </nav>

        <!-- Pipeline Overview -->
        <div class="step">
            <h2>üîÑ ML Pipeline Overview</h2>
            <div class="pipeline-viz">
                <div class="pipeline-step" onclick="scrollToStep(1)">
                    <div>üìã</div>
                    <div>Frame Problem</div>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="pipeline-step" onclick="scrollToStep(2)">
                    <div>üìä</div>
                    <div>Get Data</div>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="pipeline-step" onclick="scrollToStep(3)">
                    <div>üîç</div>
                    <div>Explore</div>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="pipeline-step" onclick="scrollToStep(4)">
                    <div>üõ†Ô∏è</div>
                    <div>Prepare</div>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="pipeline-step" onclick="scrollToStep(5)">
                    <div>ü§ñ</div>
                    <div>Train</div>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="pipeline-step" onclick="scrollToStep(6)">
                    <div>‚öôÔ∏è</div>
                    <div>Fine-tune</div>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="pipeline-step" onclick="scrollToStep(7)">
                    <div>üéØ</div>
                    <div>Evaluate</div>
                </div>
            </div>
        </div>

        <!-- Step 1: Frame the Problem -->
        <div class="step" id="step1">
            <div class="step-header">
                <div class="step-number">1</div>
                <div class="step-title">Frame the Problem</div>
            </div>

            <div class="concept-box problem">
                <div class="concept-title">üéØ Problem Definition</div>
                <p>Predict California housing prices based on district-level features. This is a <strong>supervised learning</strong> task since we have labeled data (actual prices).</p>
            </div>

            <div class="concept-box solution">
                <div class="concept-title">üîß Solution Approach</div>
                <ul>
                    <li><strong>Task Type:</strong> Regression (predicting continuous values)</li>
                    <li><strong>Performance Measure:</strong> RMSE (Root Mean Square Error)</li>
                    <li><strong>Learning Type:</strong> Batch learning (train on entire dataset)</li>
                </ul>
            </div>

            <div class="collapsible">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <span>ü§î Why These Choices?</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <p><strong>Regression vs Classification:</strong> We're predicting house prices (continuous values), not categories.</p>
                    <p><strong>RMSE vs MAE:</strong> RMSE penalizes large errors more heavily, which is important for housing prices where large errors are costly.</p>
                    <p><strong>Batch vs Online Learning:</strong> Housing data doesn't change rapidly, so batch learning is sufficient.</p>
                </div>
            </div>

            <div class="interactive-demo">
                <h4>üéÆ Interactive: Problem Type Selector</h4>
                <p>Select different scenarios to see how the problem type changes:</p>
                <select id="problemSelector" onchange="updateProblemType()">
                    <option value="regression">House Price Prediction</option>
                    <option value="classification">Spam Email Detection</option>
                    <option value="clustering">Customer Segmentation</option>
                </select>
                <div id="problemTypeResult" style="margin-top: 1rem; padding: 1rem; background: #e3f2fd; border-radius: 5px;">
                    <strong>Task:</strong> Regression | <strong>Learning:</strong> Supervised | <strong>Metric:</strong> RMSE
                </div>
            </div>
        </div>

        <!-- Step 2: Get the Data -->
        <div class="step" id="step2">
            <div class="step-header">
                <div class="step-number">2</div>
                <div class="step-title">Get the Data</div>
            </div>

            <div class="concept-box">
                <div class="concept-title">üìä Data Acquisition</div>
                <p>Load the California housing dataset and perform initial inspection.</p>
            </div>

            <div class="collapsible">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <span>üíª Code: Loading Data</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
import pandas as pd
import numpy as np
from sklearn.datasets import fetch_california_housing

# Load the dataset
housing = fetch_california_housing(as_frame=True)
housing_df = housing.frame

# Basic info
print(f"Shape: {housing_df.shape}")
print(f"Features: {housing.feature_names}")
print(f"Target: {housing.target_names}")
                    </div>
                </div>
            </div>

            <div class="concept-box solution">
                <div class="concept-title">üìã Dataset Overview</div>
                <div class="results-grid">
                    <div class="metric-card">
                        <div class="metric-value">20,640</div>
                        <div class="metric-label">Total Samples</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">8</div>
                        <div class="metric-label">Features</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Missing Values</div>
                    </div>
                </div>
            </div>

            <div class="tooltip">
                Stratified Sampling
                <span class="tooltiptext">
                    We use stratified sampling to ensure our train/test split maintains the same distribution of income categories as the full dataset. This prevents sampling bias and ensures our test set is representative.
                </span>
            </div>
            <p> is crucial for maintaining data distribution across train/test splits.</p>
        </div>

        <!-- Step 3: Explore the Data -->
        <div class="step" id="step3">
            <div class="step-header">
                <div class="step-number">3</div>
                <div class="step-title">Explore the Data</div>
            </div>

            <div class="concept-box">
                <div class="concept-title">üîç Exploratory Data Analysis</div>
                <p>Understand the data through visualizations and statistical analysis.</p>
            </div>

            <div class="plot-container">
                <h4>üìä Interactive: Housing Price Distribution</h4>
                <div id="histogramPlot" style="height: 400px;"></div>
            </div>

            <div class="plot-container">
                <h4>üó∫Ô∏è Geographic Distribution</h4>
                <div id="scatterPlot" style="height: 400px;"></div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <span>üîó Code: Correlation Analysis</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
# Correlation with target
correlations = housing_df.corr()['MedHouseVal'].sort_values(ascending=False)
print("Top correlations with house prices:")
print(correlations)

# Create correlation heatmap
import seaborn as sns
import matplotlib.pyplot as plt
plt.figure(figsize=(10, 8))
sns.heatmap(housing_df.corr(), annot=True, cmap='coolwarm', center=0)
plt.title('Feature Correlation Matrix')
plt.show()
                    </div>
                </div>
            </div>

            <div class="concept-box solution">
                <div class="concept-title">üéØ Key Insights</div>
                <ul>
                    <li><strong>Median Income</strong> has the strongest correlation with house prices (0.69)</li>
                    <li><strong>Geographic clustering</strong> visible in coastal areas (higher prices)</li>
                    <li><strong>Room ratios</strong> matter more than absolute counts</li>
                    <li>Some features show <strong>tail-heavy distributions</strong> (may need transformation)</li>
                </ul>
            </div>
        </div>

        <!-- Step 4: Prepare the Data -->
        <div class="step" id="step4">
            <div class="step-header">
                <div class="step-number">4</div>
                <div class="step-title">Prepare the Data</div>
            </div>

            <div class="concept-box">
                <div class="concept-title">üõ†Ô∏è Data Preprocessing Pipeline</div>
                <p>Transform raw data into a format suitable for machine learning algorithms.</p>
            </div>

            <div class="interactive-demo">
                <h4>‚öôÔ∏è Interactive: Preprocessing Steps</h4>
                <div class="pipeline-viz">
                    <div class="pipeline-step" onclick="highlightStep('missing')">
                        <div>‚ùì</div>
                        <div>Handle Missing</div>
                    </div>
                    <div class="arrow">‚Üí</div>
                    <div class="pipeline-step" onclick="highlightStep('categorical')">
                        <div>üè∑Ô∏è</div>
                        <div>Encode Categorical</div>
                    </div>
                    <div class="arrow">‚Üí</div>
                    <div class="pipeline-step" onclick="highlightStep('scaling')">
                        <div>üìè</div>
                        <div>Scale Features</div>
                    </div>
                    <div class="arrow">‚Üí</div>
                    <div class="pipeline-step" onclick="highlightStep('engineering')">
                        <div>üîß</div>
                        <div>Feature Engineering</div>
                    </div>
                </div>
                <div id="stepDetails" style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 5px;">
                    Click on a preprocessing step above to see details!
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <span>üîß Code: Complete Pipeline</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.impute import SimpleImputer

# Create preprocessing pipeline
numerical_features = ['longitude', 'latitude', 'housing_median_age', 
                     'total_rooms', 'total_bedrooms', 'population', 
                     'households', 'median_income']

numerical_pipeline = Pipeline([
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

# Feature engineering: add room ratios
def add_room_ratios(X):
    rooms_per_household = X[:, 3] / X[:, 6]
    bedrooms_per_room = X[:, 4] / X[:, 3]
    population_per_household = X[:, 5] / X[:, 6]
    return np.c_[X, rooms_per_household, bedrooms_per_room, population_per_household]

preprocessor = ColumnTransformer([
    ('num', numerical_pipeline, numerical_features)
])
                    </div>
                </div>
            </div>

            <div class="concept-box solution">
                <div class="concept-title">‚úÖ Preprocessing Benefits</div>
                <ul>
                    <li><strong>Imputation:</strong> Handles missing values without losing data</li>
                    <li><strong>Scaling:</strong> Ensures all features contribute equally to distance-based algorithms</li>
                    <li><strong>Feature Engineering:</strong> Creates meaningful ratios that often predict better than raw counts</li>
                    <li><strong>Pipeline:</strong> Ensures consistent preprocessing for training and inference</li>
                </ul>
            </div>
        </div>

        <!-- Step 5: Train Models -->
        <div class="step" id="step5">
            <div class="step-header">
                <div class="step-number">5</div>
                <div class="step-title">Select and Train Models</div>
            </div>

            <div class="concept-box">
                <div class="concept-title">ü§ñ Model Selection</div>
                <p>Compare different algorithms to find the best starting point.</p>
            </div>

            <div class="interactive-demo">
                <h4>üèÅ Model Comparison</h4>
                <div class="results-grid">
                    <div class="metric-card" onclick="selectModel('linear')">
                        <div class="metric-value">68,628</div>
                        <div class="metric-label">Linear Regression<br>RMSE</div>
                    </div>
                    <div class="metric-card" onclick="selectModel('tree')">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Decision Tree<br>RMSE (overfitting!)</div>
                    </div>
                    <div class="metric-card" onclick="selectModel('forest')">
                        <div class="metric-value">18,603</div>
                        <div class="metric-label">Random Forest<br>RMSE ‚≠ê</div>
                    </div>
                </div>
                <div id="modelDetails" style="margin-top: 1rem; padding: 1rem; background: #e8f5e8; border-radius: 5px;">
                    <strong>Random Forest</strong> shows the best performance with good generalization!
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <span>üìä Code: Cross-Validation</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
from sklearn.model_selection import cross_val_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor

# Test multiple models
models = {
    'Linear Regression': LinearRegression(),
    'Decision Tree': DecisionTreeRegressor(),
    'Random Forest': RandomForestRegressor(n_estimators=100, random_state=42)
}

for name, model in models.items():
    scores = cross_val_score(model, X_train_prepared, y_train, 
                           scoring='neg_mean_squared_error', cv=10)
    rmse_scores = np.sqrt(-scores)
    print(f"{name}: {rmse_scores.mean():.0f} (+/- {rmse_scores.std() * 2:.0f})")
                    </div>
                </div>
            </div>

            <div class="concept-box problem">
                <div class="concept-title">‚ö†Ô∏è Overfitting Alert</div>
                <p>Decision Tree shows perfect training performance (RMSE = 0) but poor generalization. This is a classic sign of overfitting!</p>
            </div>
        </div>

        <!-- Step 6: Fine-tune the Model -->
        <div class="step" id="step6">
            <div class="step-header">
                <div class="step-number">6</div>
                <div class="step-title">Fine-tune the Model</div>
            </div>

            <div class="concept-box">
                <div class="concept-title">‚öôÔ∏è Hyperparameter Tuning</div>
                <p>Optimize model performance through systematic parameter search.</p>
            </div>

            <div class="interactive-demo">
                <h4>üéõÔ∏è Interactive: Hyperparameter Impact</h4>
                <div class="slider-container">
                    <label for="nEstimators">Number of Trees: <span id="nEstimatorsValue">100</span></label>
                    <input type="range" id="nEstimators" class="slider" min="10" max="200" value="100" 
                           oninput="updateHyperparameter('n_estimators', this.value)">
                </div>
                <div class="slider-container">
                    <label for="maxDepth">Maximum Depth: <span id="maxDepthValue">10</span></label>
                    <input type="range" id="maxDepth" class="slider" min="3" max="20" value="10" 
                           oninput="updateHyperparameter('max_depth', this.value)">
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="estimatedRMSE">18,603</div>
                    <div class="metric-label">Estimated RMSE</div>
                </div>
            </div>

            <div class="collapsible">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <span>üîç Code: Grid Search</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
from sklearn.model_selection import GridSearchCV

# Define parameter grid
param_grid = {
    'n_estimators': [50, 100, 200],
    'max_depth': [None, 10, 20],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}

# Grid search with cross-validation
grid_search = GridSearchCV(
    RandomForestRegressor(random_state=42),
    param_grid,
    cv=5,
    scoring='neg_mean_squared_error',
    n_jobs=-1
)

grid_search.fit(X_train_prepared, y_train)
print("Best parameters:", grid_search.best_params_)
print("Best RMSE:", np.sqrt(-grid_search.best_score_))
                    </div>
                </div>
            </div>

            <div class="concept-box solution">
                <div class="concept-title">üéØ Best Parameters Found</div>
                <ul>
                    <li><strong>n_estimators:</strong> 100 (more trees = better performance, but diminishing returns)</li>
                    <li><strong>max_depth:</strong> None (let trees grow deep, but monitor overfitting)</li>
                    <li><strong>min_samples_split:</strong> 2 (allow fine-grained splits)</li>
                    <li><strong>Final RMSE:</strong> ~47,730 (significant improvement!)</li>
                </ul>
            </div>

            <div class="tooltip">
                Feature Importance
                <span class="tooltiptext">
                    Random Forest provides feature importance scores based on how much each feature decreases impurity when used for splits. Median income is typically the most important feature for housing prices.
                </span>
            </div>
            <p> analysis reveals which features drive predictions most.</p>
        </div>

        <!-- Step 7: Evaluate and Launch -->
        <div class="step" id="step7">
            <div class="step-header">
                <div class="step-number">7</div>
                <div class="step-title">Evaluate and Launch</div>
            </div>

            <div class="concept-box">
                <div class="concept-title">üéØ Final Evaluation</div>
                <p>Test the final model on unseen data and prepare for deployment.</p>
            </div>

            <div class="plot-container">
                <h4>üìà Prediction vs Actual</h4>
                <div id="predictionPlot" style="height: 400px;"></div>
            </div>

                            <div class="results-grid">
                <div class="metric-card">
                    <div class="metric-value">47,730</div>
                    <div class="metric-label">Test RMSE</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">0.64</div>
                    <div class="metric-label">R¬≤ Score</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">¬±15%</div>
                    <div class="metric-label">Typical Error</div>
                </div>
            </div>

            <div class="concept-box solution">
                <div class="concept-title">‚úÖ Model Performance Summary</div>
                <ul>
                    <li><strong>RMSE:</strong> $47,730 - Most predictions within ~$48k of actual price</li>
                    <li><strong>R¬≤ Score:</strong> 0.64 - Model explains 64% of price variance</li>
                    <li><strong>Business Impact:</strong> Good enough for initial property valuations</li>
                    <li><strong>Error Analysis:</strong> Larger errors on expensive properties (>$500k)</li>
                </ul>
            </div>

            <div class="collapsible">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <span>üöÄ Code: Production Pipeline</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div class="code-block">
import joblib
from sklearn.pipeline import Pipeline

# Create full pipeline (preprocessing + model)
full_pipeline = Pipeline([
    ('preprocessing', preprocessor),
    ('random_forest', grid_search.best_estimator_)
])

# Train on full training set
full_pipeline.fit(X_train, y_train)

# Save model for production
joblib.dump(full_pipeline, 'housing_model.pkl')

# Example prediction function
def predict_price(longitude, latitude, housing_median_age, 
                 total_rooms, total_bedrooms, population, 
                 households, median_income):
    features = np.array([[longitude, latitude, housing_median_age,
                         total_rooms, total_bedrooms, population,
                         households, median_income]])
    return full_pipeline.predict(features)[0]

# Test prediction
sample_price = predict_price(-122.23, 37.88, 41, 880, 129, 322, 126, 8.3252)
print(f"Predicted price: ${sample_price:,.2f}")
                    </div>
                </div>
            </div>

            <div class="interactive-demo">
                <h4>üè† Try the Model!</h4>
                <p>Adjust the sliders to see how different features affect house prices:</p>
                
                <div class="slider-container">
                    <label for="medianIncome">Median Income (x$10k): <span id="medianIncomeValue">5.0</span></label>
                    <input type="range" id="medianIncome" class="slider" min="0.5" max="15" step="0.1" value="5.0" 
                           oninput="updatePrediction()">
                </div>
                
                <div class="slider-container">
                    <label for="houseAge">House Age (years): <span id="houseAgeValue">20</span></label>
                    <input type="range" id="houseAge" class="slider" min="1" max="52" value="20" 
                           oninput="updatePrediction()">
                </div>
                
                <div class="slider-container">
                    <label for="roomsPerHousehold">Rooms per Household: <span id="roomsPerHouseholdValue">6</span></label>
                    <input type="range" id="roomsPerHousehold" class="slider" min="3" max="15" step="0.1" value="6" 
                           oninput="updatePrediction()">
                </div>

                <div class="metric-card">
                    <div class="metric-value" id="predictedPrice">$280,000</div>
                    <div class="metric-label">Predicted House Price</div>
                </div>
            </div>

            <div class="concept-box problem">
                <div class="concept-title">üö® Limitations & Next Steps</div>
                <ul>
                    <li><strong>Data Age:</strong> 1990 census data - need current data for production</li>
                    <li><strong>Feature Gaps:</strong> Missing school quality, crime rates, amenities</li>
                    <li><strong>Model Bias:</strong> May underperform on luxury properties</li>
                    <li><strong>Improvements:</strong> Try ensemble methods, deep learning, or more features</li>
                </ul>
            </div>
        </div>

        <!-- Summary Section -->
        <div class="step">
            <div class="step-header">
                <div class="step-number">üìö</div>
                <div class="step-title">Key Takeaways</div>
            </div>

            <div class="concept-box">
                <div class="concept-title">üéØ ML Project Lessons</div>
                <ul>
                    <li><strong>Problem Framing:</strong> Clear problem definition guides all subsequent decisions</li>
                    <li><strong>Data Quality:</strong> Good data beats fancy algorithms - always explore first</li>
                    <li><strong>Feature Engineering:</strong> Domain knowledge creates powerful features (room ratios)</li>
                    <li><strong>Model Selection:</strong> Start simple, compare multiple approaches</li>
                    <li><strong>Validation:</strong> Cross-validation prevents overfitting surprises</li>
                    <li><strong>Iteration:</strong> ML is iterative - always room for improvement</li>
                </ul>
            </div>

            <div class="concept-box solution">
                <div class="concept-title">üîÑ The ML Workflow</div>
                <p>This project demonstrates the complete ML workflow: from business problem to deployed model. Each step builds on the previous, and iteration is key to success.</p>
            </div>
        </div>
    </div>

    <script>
        // Sample California housing data for visualizations
        const housingData = [
            { longitude: -122.23, latitude: 37.88, price: 452600, income: 8.3252, age: 41 },
            { longitude: -122.22, latitude: 37.86, price: 358500, income: 8.3014, age: 21 },
            { longitude: -122.24, latitude: 37.85, price: 352100, income: 7.2574, age: 52 },
            { longitude: -122.25, latitude: 37.85, price: 341300, income: 5.6431, age: 52 },
            { longitude: -122.25, latitude: 37.84, price: 342200, income: 3.8462, age: 52 },
            { longitude: -121.22, latitude: 39.43, price: 67500, income: 1.6812, age: 25 },
            { longitude: -121.32, latitude: 39.43, price: 85800, income: 1.9911, age: 18 },
            { longitude: -121.24, latitude: 39.37, price: 69400, income: 2.3886, age: 16 },
            { longitude: -118.25, latitude: 34.05, price: 344700, income: 5.7192, age: 15 },
            { longitude: -118.26, latitude: 34.04, price: 249700, income: 4.3299, age: 19 }
        ];

        // Initialize plots
        function initializePlots() {
            // Histogram plot
            const priceData = housingData.map(d => d.price);
            const histogramTrace = {
                x: priceData,
                type: 'histogram',
                nbinsx: 20,
                marker: { color: '#3498db', opacity: 0.7 },
                name: 'House Prices'
            };

            Plotly.newPlot('histogramPlot', [histogramTrace], {
                title: 'Distribution of House Prices',
                xaxis: { title: 'Price ($)' },
                yaxis: { title: 'Frequency' },
                bargap: 0.1
            });

            // Scatter plot (geographic)
            const scatterTrace = {
                x: housingData.map(d => d.longitude),
                y: housingData.map(d => d.latitude),
                mode: 'markers',
                marker: {
                    size: housingData.map(d => Math.sqrt(d.price) / 100),
                    color: housingData.map(d => d.price),
                    colorscale: 'Viridis',
                    showscale: true,
                    colorbar: { title: 'Price ($)' }
                },
                text: housingData.map(d => `Price: ${d.price.toLocaleString()}<br>Income: ${(d.income * 10000).toLocaleString()}`),
                hovertemplate: '%{text}<extra></extra>',
                name: 'Housing Districts'
            };

            Plotly.newPlot('scatterPlot', [scatterTrace], {
                title: 'Geographic Distribution of Houses (Sample)',
                xaxis: { title: 'Longitude' },
                yaxis: { title: 'Latitude' }
            });

            // Prediction vs Actual plot
            const actualPrices = [452600, 358500, 352100, 341300, 342200, 67500, 85800, 69400, 344700, 249700];
            const predictedPrices = [440000, 370000, 340000, 350000, 330000, 75000, 90000, 65000, 360000, 260000];

            const perfectLineTrace = {
                x: [0, 500000],
                y: [0, 500000],
                mode: 'lines',
                line: { color: 'red', dash: 'dash' },
                name: 'Perfect Prediction'
            };

            const predictionTrace = {
                x: actualPrices,
                y: predictedPrices,
                mode: 'markers',
                marker: { 
                    size: 10, 
                    color: '#3498db',
                    line: { color: 'white', width: 2 }
                },
                name: 'Predictions'
            };

            Plotly.newPlot('predictionPlot', [perfectLineTrace, predictionTrace], {
                title: 'Model Predictions vs Actual Prices',
                xaxis: { title: 'Actual Price ($)' },
                yaxis: { title: 'Predicted Price ($)' }
            });
        }

        // Utility functions
        function scrollToStep(stepNumber) {
            document.getElementById(`step${stepNumber}`).scrollIntoView({ behavior: 'smooth' });
        }

        function toggleCollapsible(element) {
            const content = element.nextElementSibling;
            const icon = element.querySelector('.toggle-icon');
            
            content.classList.toggle('active');
            icon.classList.toggle('active');
        }

        function updateProblemType() {
            const selector = document.getElementById('problemSelector');
            const result = document.getElementById('problemTypeResult');
            
            const scenarios = {
                'regression': 'Task: Regression | Learning: Supervised | Metric: RMSE',
                'classification': 'Task: Classification | Learning: Supervised | Metric: Accuracy/F1-Score',
                'clustering': 'Task: Clustering | Learning: Unsupervised | Metric: Silhouette Score'
            };
            
            result.innerHTML = `<strong>${scenarios[selector.value]}</strong>`;
        }

        function highlightStep(stepType) {
            const details = document.getElementById('stepDetails');
            const stepInfo = {
                'missing': {
                    title: 'Handle Missing Values',
                    content: 'Use median imputation for numerical features. Median is robust to outliers and works well for housing data where missing values might not be random.'
                },
                'categorical': {
                    title: 'Encode Categorical Features',
                    content: 'Convert text categories (like ocean_proximity) to numbers. Use one-hot encoding for nominal categories or ordinal encoding for ordered categories.'
                },
                'scaling': {
                    title: 'Scale Features',
                    content: 'Standardize numerical features to have mean=0 and std=1. This ensures all features contribute equally to distance-based algorithms like SVM or KNN.'
                },
                'engineering': {
                    title: 'Feature Engineering',
                    content: 'Create new features that capture domain knowledge. Room ratios (rooms/household) often predict better than raw room counts.'
                }
            };
            
            const info = stepInfo[stepType];
            details.innerHTML = `<strong>${info.title}</strong><br>${info.content}`;
        }

        function selectModel(modelType) {
            const details = document.getElementById('modelDetails');
            const modelInfo = {
                'linear': 'Linear Regression assumes linear relationships. Good baseline but may be too simple for complex housing patterns.',
                'tree': 'Decision Tree perfectly fits training data but overfits badly. Single trees are prone to high variance.',
                'forest': 'Random Forest combines many trees to reduce overfitting while maintaining flexibility. Best balance of bias-variance!'
            };
            
            details.innerHTML = `<strong>Selected:</strong> ${modelInfo[modelType]}`;
        }

        function updateHyperparameter(param, value) {
            document.getElementById(param === 'n_estimators' ? 'nEstimatorsValue' : 'maxDepthValue').textContent = value;
            
            // Simulate RMSE change based on parameters
            const baseRMSE = 20000;
            const nEst = parseInt(document.getElementById('nEstimators').value);
            const maxDepth = parseInt(document.getElementById('maxDepth').value);
            
            // Simple simulation: more trees and deeper trees generally improve performance
            const estimatedRMSE = baseRMSE - (nEst * 10) - (maxDepth * 200) + Math.random() * 5000;
            document.getElementById('estimatedRMSE').textContent = Math.max(15000, estimatedRMSE).toFixed(0);
        }

        function updatePrediction() {
            const income = parseFloat(document.getElementById('medianIncome').value);
            const age = parseInt(document.getElementById('houseAge').value);
            const rooms = parseFloat(document.getElementById('roomsPerHousehold').value);
            
            // Update display values
            document.getElementById('medianIncomeValue').textContent = income.toFixed(1);
            document.getElementById('houseAgeValue').textContent = age;
            document.getElementById('roomsPerHouseholdValue').textContent = rooms.toFixed(1);
            
            // Simple prediction formula (simplified version of what the model might do)
            const basePrice = 100000;
            const incomeEffect = income * 25000; // Higher income areas = higher prices
            const ageEffect = Math.max(0, (50 - age)) * 1000; // Newer houses worth more
            const roomEffect = (rooms - 4) * 15000; // More rooms = higher price
            
            const predictedPrice = basePrice + incomeEffect + ageEffect + roomEffect;
            document.getElementById('predictedPrice').textContent = `${predictedPrice.toLocaleString()}`;
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializePlots();
            updatePrediction();
        });
    </script>
</body>
</html>